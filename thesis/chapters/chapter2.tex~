%-*-coding: utf-8-*-
\chapter{Описание алгоритма}

В данной главе рассмотрен алгоритм для поиска корректно-синхронизированных полей.
Поле является корректно-синхронизированным, когда существует такая блокировка, что любая операция с полем проводится с этой блокировкой. Алгоритм ищет для полей такие блокировки. 
Алгоритм можно разделить на 3 части. 
\begin{enumerate}
\item Получение промежуточного представления и графа потока исполнения.
\item Получение множества возможных блокировок.
\item Обход графа потока исполнения и выделение корректно-синхронизированных полей.
\end{enumerate}

В первом разделе рассмотрено промежуточное представление, на основе которого построен граф потока исполнения. Во втором показано, как выделить множество переменных, которые могут являться блокировкой. Эта часть алгоритма необходима, так как при статическом анализе не каждая локальная переменная и не каждое поле может являться потенциальной блокировкой. 
В третьем разделе рассмотрена основная часть алгоритма --- обход графа потока исполнения, отслеживание и обработка операций синхронизации и обращений к полям, выделение корректно-синхронизированных полей.

\FloatBarrier
\section{Описание промежуточного представления и CFG для него}
В настоящее время существует достаточное количество готовых библиотек для получения различных промежуточных представлений и графов потока исполнения. 
Для данной работы было выбрано промежуточное представление приведенное в $SSA$-форму \cite{SSA}. $SSA$-форма технически упрощает получение множества блокировок. В промежуточном представлении, используемом в данной работе, вся работа со стеком заменена на локальные переменные. Как и в байт-коде имеется две примитивные операции синхронизации: $monitorEnter$ и $monitorExit$. Эти операции отвечают за взятие и освобождение монитора объекта.

Каждая переменная имеет единственное место присваивания, так как представление удовлетворяет $SSA$ форме. 
Для присваивания переменной может использоваться $\phi$-функция.
Если локальная переменная может принимать несколько значений, то данная переменная присваивается $\phi$-функции из всех возможных ее значений.
Промежуточное представление и $CFG$ получены с помощью библиотеки $Soot$ \cite{Soot}. Присваивания в данном представлении удовлетворяют следующей грамматике($local$ --- локальная переменная, $field$ --- поле класса, $constant$ -- константа).

\begin{table}[H]
\label{grammar}
\begin{center}
\begin{tabular}{|c|c|}
\hline

\multirow{2}{*}{imm}  & $local$ \\
		      & $constant$ \\
\hline
\multirow{5}{*}{expr} & $imm_1\ binop\ imm_2$ \\
		      & (type) $imm$ \\
		      & $imm_1$ instanceof type \\
      		      & invokeExpr \\
      		      & $new$ refType \\
      		      & $newarray$ (type) [imm] \\
		      & $neg\ imm$ \\
\hline
\multirow{4}{*}{assignStmt} & $local$ = $\phi$($imm_1$, $imm_2$, ...) \\ 
			    & $local$ = $imm$ | $field$ | $local.field$ | $expr$  \\ 
		            & $field$ = $imm$ \\
			    & $local.field$ = $imm$ \\
\hline
\end{tabular}
\captionsetup{justification=centering}
\caption{Грамматика присваиваний используемого IR}
\end{center}

\end{table}

Также в данном языке, выделены операции инициализации. Они используются для того чтобы получить ссылку на $this$, на возникший $exception$ или на аргумент функции. 


Далее приведен простейший пример метода, его промежуточное представление и $CFG$.
\\
\\

\lstinputlisting[caption=Пример Java-программы., language=Java, label=JavaExample]{code/Example.java}

\lstinputlisting[caption=Описанное промежуточное представление., language=Java, label=Shimple]{code/Example.shimp}

\drawfigurex{CFG.png}{Схема CFG метода.}{CFG}{0.55\textwidth}


\FloatBarrier
\section{Получение множества возможных блокировок}
Алгоритм должен быть точным, то есть сообщать только о тех полях, которые действительно корректно-синхронизированы.

В полученном в предыдущем разделе представлении операция взятия блокировки осуществляется с локальной переменной.
Под \emph{блокировкой} подразумевается ссылка на объект, по которому осуществляется синхронизация(носитель монитора при встроенной синхронизации или объект блокировки для java.util.concurrent).

При обходе графа, который будет рассмотрен в следующей главе, нужно поддерживать текущее множество взятых блокировок.
Если нельзя статически доказать, что локальная переменная всегда ссылается на одно поле, или переменная ссылается на поле, которое может измениться, то операции взятия блокировки по таким переменным не должна добавлять информацию относительно взятых блокировок.
В листинге \ref{PhiLock} демонстрируется соответствующий пример.
\lstinputlisting[caption=Блокировка с несколькими возможными значениями., language=Java, label=PhiLock]{code/PhiLock.java}

В данном примере переменная $lock$ может ссылаться на поле $lock1$ и $lock2$. Статическим анализом нельзя выяснить значение переменной $lock$. Таким образом, операция  синхронизации не должна изменять множество взятых блокировок.

\subsection{Нахождение переменных, которые могут ссылаться на разные поля}
В данном разделе будет показано, как найти все локальные переменные, которые могут иметь не единственное значение.
Так как полученное представление является $SSA$, то каждая переменная имеет единственное место инициализации. 
Если переменная инициализируется как $\phi$-функция, то эта переменная может иметь не единственное значение. Также если локальная переменная $l1$ принимает значение другой локальной переменной $l2$ или поля локальной переменной $l2.field$, и $l2$ может иметь не единственное значение, то $l1$ тоже может иметь не единственное значение и не может являться блокировкой.

Рассмотрим алгоритм. Сначала выделим множество переменных, которые инициализируются $\phi$-функциями. Затем построим замыкание данного множества относительно операций присваивания. Полученное множество, очевидно, будет искомым.

\subsection{Нахождение переменных, ссылающихся на не final поля}
\lstinputlisting[caption=Блокировка по полю другого класса., language=Java, label=FinalLockA]{code/FinalLockA.java}

В листинге \ref{FinalLockA} показан пример, когда берется блокировка по полю другого класса. 
Чтобы являться блокировкой, поле $b$ класса $A$ должно иметь модификатор $final$, и поле $lock$ класса $B$ также должно быть $final$. В общем случае каждое поле в пути блокировки должно иметь модификатор $final$. Отметим, что данные рассуждения относятся к не $static$ полям. В случае со $static$ полями достаточно проверить, что поле имеет модификатор $final$.

Алгоритм будет следующим. Сначала выделим множество переменных, которые непосредственно ссылаются на не $final$ поля. Затем построим замыкание данного множества относительно операций присваивания. Полученное множество, очевидно будет искомым.
\\

\section{Обход графа потока исполнения}
В данной главе будет рассмотрен алгоритм обхода $CFG$. Описан обход, обработка операций синхронизации и обращений к полям. 

Обход является рекурсивным, напоминает обход в глубину, но с некоторыми отличиями. При обходе поддерживается множество текущих взятых блокировок $curLocks$. Также для каждой вершины $CFG$ хранится множество блокировок, с которыми обход уже посещал данную вершину $v.locks$.
При входе в вершину $v$ нужно сравнить $curLocks$ и $v.locks$. Если $v.locks \subseteq curLocks$, то можно не продолжать обход вершины $v$. Если $v.locks \nsubseteq curLocks$, то в $v.locks$ и $curLocks$ запишем  $v.locks \cap curLocks$ и продолжим обход. Записывать нужно пересечение, так как если существует ветка обхода, в которой вершина $v$ посещена без блокировки $l$, то нельзя гарантировать, что операция вершины $v$ защищена блокировкой $l$. 

Изменять $curLocks$ нужно при операциях взятия и освобождения блокировки. Для каждого поля сохраним множество блокировок, с которыми обращались к данному полю $f.locks$. При обращении к полю $f$ нужно пересечь $f.locks$ и 
$currentLocks$.
Далее приведен псевдокод описанного алгоритма.

\begin{algorithm}
\caption{Алгоритм обхода $CFG$ метода}\label{alg:TraverseCFG}
\begin{algorithmic}
\Function{visit}{CFGVertex v,  Set<Lock> currentLocks}
\If {v.locks $\subseteq$ currentLocks}
	\State break
\Else
	\State v.locks $\gets$ v.locks $\cap$ currentLocks 
	\State currentLocks $\gets$ v.locks $\cap$ currentLocks 
\EndIf
\State op $\gets$ v.getOperation()
\If {op.isMonitorEnterOperation()}
	\State currentLocks.add(v.getOperations.getLock())
\EndIf
\If {op.isMonitorExitOperation()}
	\State currentLocks.remove(v.getOperations.getLock())
\EndIf

\If {op.isFieldAssignmentOperation()}
	\State field $\gets$ op.getField()
	\State field.locks $\gets$ field.locks $\cap$ currentLocks
\EndIf

\ForAll{CFGVertex c : v.childs}
	\State \Call {visit}{c, currentLocks}
\EndFor

\EndFunction
 
\end{algorithmic}
\end{algorithm}

\FloatBarrier

Далее более подробно рассмотрена обработка операций синхронизации и обращений к полям.

\subsection{Обработка операций синхронизации}
Если при обходе встретилась операция синхронизации, то нужно изменить $currentLocks$. Но сначала нужно проверить, что переменная, над которой осуществляется операция синхронизации, может являться блокировкой. 
Данная проверка описана в предыдущем разделе. Далее, если текущая операция --- операция взятия блокировки, то добавляем блокировку в $currentLocks$; а если операция освобождения, то удаляем блокировку из $currentLocks$. Помимо стандартных операций $monitorEnter$ и $monitorExit$ в данной работе рассмотрены блокировки пакета java.util.concurrent и их парные операции $lock()$ и $unlock()$.

\subsection{Обработка обращений к полям}
При обращении к полю может возникнуть состояние гонки. Но, если существует блокировка $l$, такая что любая операция чтения  и записи с полем $v$ производится со взятой $l$, то поле $v$ корректно-синхронизировано. Таким образом, для каждого поля $f$ надо поддерживать множество блокировок $f.locks$, с которыми гарантировано обращались к данному полю. А при обращении к полю $f$ сужать $f.locks$ до пересечения $f.locks$ и $currentLocks$. 


\subsection{Обработка методов, защищенных блокировкой}
Пока в работе рассматривался обход $CFG$ каждого метода независимо. Но существуют методы, вызовы которых  всегда защищены определенной блокировкой. Соответственно, любая операция в данном методе защищена этой блокировкой. Анализ методов может добавить информации относительно текущих блокировок, что приведет к увеличению найденных корректно-синхронизированных полей. Предварительно выделив для метода множество блокировок, с которым он гарантировано вызывается, можно улучшить анализ.

\lstinputlisting[caption=Класс без внутренней синхронизации., language=Java, label=Method]{code/Methods.java}

На листинге \ref{Method} показан пример класса, в котором отсутствует синхронизация. Однако, если все вызовы $getX()$ и $setX()$ защищены одной блокировкой, то все обращения к полю $x$ защищены этой же блокировкой. Таким образом, получим, что поле $x$ корректно-синхронизировано.

Рассмотрим алгоритм поиска блокировок, которыми защищен метод. Метод $m$ \emph{защищен блокировкой} $l$, если любая операция вызова метода $m$ защищена блокировкой $l$. Для поиска блокировок, которыми защищен метод, можно использовать алгоритм аналогичный алгоритму для поиска корректно-синхронизированных полей. Для каждого метода $m$ надо поддерживать множество блокировок $m.locks$, с которыми гарантировано вызывался данный метод. При операции вызова метода $m$ записывать в $m.locks$ пересечение $currentLocks$ и $m.locks$.

После одного обхода для каждого метода $m$ будет сформирован $m.locks$. Далее можно повторить обход графа с появившимися новыми блокировками. Второй и последующие обходы нужны, так как после каждого обхода множество блокировок, которые защищают метод может увеличиться. Если после очередного обхода в множество блокировок, защищающих метод $m$, добавлена блокировка $l$, то все операции метода $m$ защищены $l$. Это означает, что при следующем обходе, любой метод $k$, вызываемый из $m$ может стать защищенным блокировкой $l$. Оценим количество таких обходов. Если после очередного обхода для каждого метода $m$ не изменилось $m.locks$, то можно завершать алгоритм. Теоретически может понадобиться $n \times m$ обходов ($n$ --- количество анализируемых методов, $m$ --- количество блокировок, которыми защищен хотя бы один метод). На практике нескольких (трех или четырех) таких обходов достаточно, так как операции синхронизации редко используются для того, чтобы синхронизировать операции через пять вызовов метода.

Также при обработке методов необходимо корректно обрабатывать виртуальные методы. Класс, у которого будет вызван метод, можно определить только во время выполнения. При статическом анализе можно утверждать, что при вызове метода $m$ у объекта типа $t$ будет выполнен метод одного из наследников класса $t$. Таким образом, метод $m$ класса $t$ гарантировано защищен блокировкой $l$, если все вызовы метода $m$ предков класса $t$ защищены $l$.  

\FloatBarrier
