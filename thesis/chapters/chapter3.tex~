%-*-coding: utf-8-*-
\chapter{Практическая реализация алгоритма}

В рамках данной работы была написана программа для поиска корректно-синхронизированных полей, использующая алгоритм из предыдущего раздела. Программа написана на языке программирования Java и интегрирована с jDRD.

\FloatBarrier
\section{Особенности реализации}
Данная программа имеет два режима работы: \emph{локальный} и \emph{глобальный}. \emph{Локальный} режим подразумевает, что анализируемый код
может использоваться сторонними приложениями, не входящими в область анализа. Таким образом, если поле или метод корректно-синхронизировано в рамках анализируемой программы, но оно доступно для изменения, то в локальном режиме оно не считается корректно-синхронизированным. Такой режим нужен для анализа различных библиотек. \emph{Глобальный} режим подразумевает, что 
анализируемый код используется только из области анализа. Если поле корректно-синхронизировано в рамках анализируемой программы, то даже если оно доступно для изменения, глобальный режим отметит его как корректно-синхронизированное. Данный режим предназначен для тестирования законченных приложений. Множество переменных, выделенное в глобальном режиме включает в себя множество, выделенное при работе в локальном режиме.



В листинге \ref{Account} поле $balance$ корректно-синхронизировано, и будет выделено при работе программы и в локальном, и в глобальном режиме. Если убрать модификатор $private$ у поля $balance$ и предположить, что в рамках программы снаружи к полю $balance$ не обращаются, то оно будет корректно-синхронизировано только с точки зрения глобального режима.

\lstinputlisting[caption=Пример корректно-синхронизированного поля для локального режима., language=Java, label=Account]{code/Account.java}

Программа на вход принимает скомпилированные файлы Java-программ. На вход ей можно подать либо $jar$-файл с программой, либо указать путь до папки с $class$-файлами.  Промежуточное представление и граф потока исполнения получены на основе байт-кода с помощью библиотеки $Soot$ \cite{SootPage}. Промежуточное представление, используемое в данной работе для анализа, называется $Shimple$ \cite{Soot}.


\FloatBarrier
\section{Тестирование}
Было проведено тестирование разработанной программы на различных тестах. Создан набор тестов, покрывающий большинство конструкций Java-программ. В качестве тестов были использованы программы использующие различные операции синхронизации, обработку ошибок(exception), статические и нестатические блокировки и поля, внутренние классы и т.д.

Также были проведены запуски на реальных библиотеках и приложениях с последующей проверкой результатов.

\FloatBarrier
\section{Сбор статистики и интеграция с jDRD}
В программу статического анализа был добавлен модуль сбора статистики, который подсчитывает различные метрики работы алгоритма. Этот модуль необходим для оценки результата работы программы.

jDRD получает список корректно-синхронизированных полей через конфигурационный файл, генерируемый разработанной программой.
В jDRD был также включен сбор статистики, который отслеживает количество обращений к корректно-синхронизированным полям, выделенным статическим анализом.


\section{Полученные результаты}
Программа была запущена на различных приложениях, которые активно используют конкурентный доступ к данным. 
Далее представлено краткое описание тестируемых библиотек.
\\MARS(Monitoring and reporting system) --- система мониторинга реального времени. Используется для отображения различных данных приложения. 
\\ dxFeed --- система, отвечающая за быструю доставку больших данных(котировок).
\\ Tomcat --- контейнер сервлетов. Позволяет запускать веб-приложения.
\\ jtt --- система менеджмента времени, использующая в качестве сервера JIRA.

Результаты приведены в таблице. 

\begin{table}[H]
\label{results}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Приложение & Общее количество полей & Корректно-синхронизированных полей & Процент \\
\hline
dxFeed & 5212 & 982 & 19 \\
\hline
MARS & 2311 & 477 & 21 \\
\hline
Tomcat & 6793 & 1546 & 23 \\
\hline
jtt & 1165 & 176 & 15 \\
\hline
\end{tabular}
\captionsetup{justification=centering}
\caption{Полученные результаты.}
\end{center}
\end{table}

Полученные данные верны с теоретической точки зрения. С практической точки зрения важны найденные не final поля. 

\begin{table}[H]
\label{results}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Приложение & Общее количество полей & Корректно-синхронизированных полей & Процент \\
\hline  
dxFeed & 1555 & 89 & 6 \\
\hline
MARS & 545 & 20 & 4 \\
\hline
Tomcat & 2924 & 132 & 5 \\
\hline
jtt & 405 & 28 & 7 \\
\hline

\end{tabular}
\captionsetup{justification=centering}
\caption{Полученные результаты, без учета final полей.}
\end{center}
\end{table}
Практические результаты имеют перспективы развития. Большинство найденных не final полей представляют нетривиальные структуры данных. Согласно работе \cite{Whaley:1999:CPE:320385.320400}, можно доказать, что некоторые объекты не покидают одного потока. Тогда, для динамического детектора можно отключить любые вызовы методов данного объекта.

Далее приведены найденные часто используемые паттерны, применяемые для защиты операций блокировкой.

\lstinputlisting[caption=Использование synchronized методов., language=Java, label=Pattern1]{code/Pattern1.java}

\lstinputlisting[caption=Использование блокировки для синхронизации., language=Java, label=Pattern2]{code/Pattern2.java}

\lstinputlisting[caption=Использование JUC locks для синхронизации., language=Java, label=Pattern3]{code/Pattern3.java}

\FloatBarrier
