% -*-coding: utf-8-*-
\startprefacepage

В настоящее время все большее количество устройств становится многоядерными и многопроцессорными, и вместе с этим
приходится разрабатывать эффективные параллельные программы. Но разработка программ с несколькими потоками выполнения является сложной и влечет большое количество ошибок. Одной из таких ошибок является состояние гонки (data race, race condition) --- несинхронизированные обращения из различных потоков к одному и тому же участку памяти, хотя бы одно из которых является обращением на запись. Состояние гонки в программах является частой допускаемой ошибкой, и обнаружение  данных ошибок является сложной и актуальной задачей. 

Большинство современных языков, в том числе Java, используют многопоточную модель с разделяемой памятью. Для публикации изменений, сделанных потоком, и для получения изменений, сделанных другими потоками существуют операции синхронизации.
Контракты модели памяти описывают гарантии, которые предоставляют различные операции синхронизации. Данные операции обеспечивают упорядоченность по времени между операциями. Если между операциями нет упорядочивания по времени, и хотя бы одна операция является записью, то наступает состояние гонки.

На рис. 1 показан пример программы с разделяемой памятью, в которой возникает состояние гонки.
\drawfigurexcap{RaceCondition.png}{Рис. 1 Состояние гонки в программе.}{race-cond}{0.95\textwidth}
\FloatBarrier
Возможно несколько вариантов исполнения данной программы, в том числе и корректный, при котором значение переменной $s$ после исполнения двух потоков будет равно 5. Но ожидаемый результат не гарантирован. Возможный вариант исполнения программы: 
\begin{enumerate}
\item Оба потока загружают 0 в локальные переменные.
\item Увеличивают $s$ параллельно.
\item Сохраняют (не важно в каком порядке) значение $s$.
\end{enumerate}
В результате значение переменной $s$ может оказаться 2 или 3. Также стоит отметить, что даже если все операции одного потока выполнятся раньше, чем первая операция другого, то корректный результат исполнения не гарантирован. Это связано с тем, что в данной программе нет никаких операций синхронизации, а следовательно нет никаких гарантий того, что изменения, сделанные одним потоком, будут видны другому потоку. После того, как один из потоков исполнит операцию $store$, не гарантируется, что другой поток увидит изменения.



Гонки могут возникать в различных системах и наносить большой ущерб. При отсутствии правильной синхронизации балансов счетов простое зачисление или снятие средств может работать некорректно. Поймать гонку на этапе тестирования очень сложно, поскольку обычно технические характеристики и архитектура устройств, на которых тестируется и запускается программа, сильно различаются. Гонку трудно отыскать, даже когда она уже произошла. Если гонка случилась, то испорченные данные могут долго распространяться по программе, и несоответствие может обнаружиться совсем в другом месте. Повторный запуск программы на тех же данных может не привести к возникновению гонки. Таким образом, задача автоматического обнаружения гонок является
сложной и актуальной.

В главе 1 более подробно разобраны подходы к автоматическому поиску гонок в программах. Отметим, что существует два принципиально разных подхода к обнаружению гонок : статический и динамический. Статический подход  анализирует программу без ее запуска. Динамический подход работает вместе с программой и анализирует конкретный вариант работы программы. Задача нахождения гонок статическим анализом является NP-трудной, поэтому при статическом подходе снижается точность и полнота результата. Главной проблемой динамического подхода является снижение производительности анализируемой программы. Целью данной работы является оптимизация динамического поиска гонок путем проведения предварительного статического анализа. 

Статический анализ не использует вычислительные ресурсы во время выполнения программы. С другой стороны, статическим анализом можно выделить поля, при обращении к которым не может возникнуть состояние гонки (далее корректно-синхронизированные поля).

Динамические детекторы используют достаточно большие структуры данных для полей и операций синхронизации. Информация о том, что часть полей можно не анализировать, позволит уменьшить время анализа и объем потребляемой детектором памяти.

В рамках данной работы разработан алгоритм для выделения корректно-синхронизированных полей и реализована соответствующая программа. Программа интегрирована с одним из существующих динамических детекторов.

В первой главе проведен обзор возможностей статического анализа. Также рассмотрены динамические подходы к обнаружению гонок и возможности для их улучшения. Во второй главе приведен алгоритм поиска корректно-синхронизированных полей. В третьей главе рассмотрена программная реализация алгоритма и представлены полученные результаты.
\FloatBarrier
