%-*-coding: utf-8-*-
\chapter{Возможности статического анализа для оптимизации поиска гонок}
\label{chapSVD}

В первом разделе главы рассмотрены различные подходы к поиску гонок, оценены их возможности, преимущества и недостатки. 
Во втором --- модель памяти Java, динамический детектор для Java-программ и возможности для его оптимизации статическим анализом.
Автоматические подходы к обнаружению гонок и сам динамический детектор более подробно описаны в \cite{DRD}.
В третьем разделе рассмотрены основные возможности и подходы статического анализа для решения исходной задачи.


\FloatBarrier
\section{Методы автоматического обнаружения гонок}
\subsection{Статический подход}
\label{StaticRaceDetection}
Для статического анализа требуется только исходный код или скомпилированные файлы. Проведение анализа не требует запуска программы. Но задача обнаружения гонок статическим анализом является NP-трудной \cite{RaceDetectionReview, RaceDetection}. Поэтому статически выявить гонки за приемлемое время невозможно. Существующие реализации используют различные эвристики, уменьшают глубину анализа, что приводит к существенно неточным и неполным результатам. 
Одной из наиболее эффективных существующих реализаций является Chord \cite{Chord, JChord}. В данной работе проводится анализ пар обращений к объектам. В результате выделяются пары обращений, при которых возможно возникновение гонки. Также существуют инструменты, которые проверяют, что программа удовлетворяет некоторой модели, на основании чего делается вывод, что она свободна от гонок. Примером такой модели является расширенная система типов, рассмотренная в работе \cite{Race-Free}. При данном подходе приходится проводить много ручной работы --- расставлять типовые аннотации. С другими существующими подходами и реализациями можно ознакомиться в \cite{RacerX, StaticDetection}.

Отметим основные преимущества и недостатки статического подхода. К преимуществам относится то, что в отличии от динамического подхода, теоретически возможен анализ всех участков программы, а также то, что статический подход  не использует ресурсы во время выполнения программы. Главным и существенным недостатком является
пропуск большого числа гонок, а также ложные срабатывания. 


\subsection{Динамический подход}
Динамические детекторы выполняются одновременно с программой и отслеживают синхронизационные события и обращения к разделяемым данным. Среди динамических детекторов выделяют 2 вида: 
\begin{itemize}
\item on-the-fly --- получают информацию и анализируют её во время выполнения программы \cite{Choi:2002:EPD:543552.512560};
\item post-mortem --- сохраняют информацию во время выполнения программы, а анализируют её уже после завершения работы программы \cite{PostMortem}.
\end{itemize}
Динамический анализ является неполным, так как анализируется только конкретный путь исполнения программы. Однако теоретически он гарантирует точность, то есть отсутствие ложных срабатываний. 

Для динамического анализа используются два принципиально различных алгоритма: $happens$-$before$ \cite{DRD, Happens-Before} и $lockset$ \cite{DRD, LockSet, GoldiLocks}. Также существуют гибридные алгоритмы \cite{DRD, Choi:2002:EPD:543552.512560}, которые совмещают преимущества $happens$-$before$ и $lockset$ алгоритмов. 


\FloatBarrier
\section{Динамический детектор гонок для Java-программ}

\FloatBarrier
\subsection{Модель памяти Java}
Для языка программирования Java существует спецификация его модели памяти (Java memory model, JMM), которая входит в стандарт языка. Данная спецификация содержит архитектурно-независимые гарантии исполнения многопоточных программ.
Для гарантированной загрузки изменений из памяти потока в общую память программы, а также для загрузки чужих изменений из общей памяти программы в память потока предусмотрены операции синхронизации. В JMM описано отношение $happens$-$before$. Если операция $A\ happens$-$before\ B$, то в момент начала выполнения операции $B$ видны изменения, выполненные $A$. Если операции $A$ и $B$ выполняются из разных потоков и обращаются к одному участку памяти, то они не образуют гонку тогда и только тогда, когда $A$ $happens$-$before$ $B$ либо $B$ $happens$-$before$ $A$ \cite{JMM}.



\subsection{Динамический детектор jDRD}
jDRD --- динамический детектор гонок для Java-программ. Он основан на $happens$-$before$ алгоритме \cite{DRD}. 

Рассмотрим подробнее $happens$-$before$ алгоритм, чтобы выявить места для ускорения jDRD.

Для каждого потока $t$ будут храниться векторные часы $t.vc$. Также часы будут храниться для всех разделяемых переменных $v.vc$ и синхронизационных объектов $l.vc$.
Векторные часы являются массивом целых чисел, каждая компонента которого является целым числом, отвечающим за компоненту часов соответствующего потока. В общем случае векторные часы имеют длину, равную общему числу потоков. Каждый поток хранит свою локальную копию векторных часов, синхронизируясь с копиями часов других потоков во время выполнения синхронизационных операций.
Сравнение часов происходит при обращениях к разделяемым переменным.
\\Изначально:  

\begin{itemize}
	\item $ \forall i:\ t_i.vc[i]\ :=\ 1$
	\item $ \forall i,\ j\ \neq i:\ t_i.vc[j] := 0$
	\item $ \forall v,\ j:\  v.vc[j]\ :=\ 0$
	\item $ \forall l,\ j:\  l.vc[j]\ :=\ 0$
\end{itemize}
При захвате потоком $t$ синхронизационного объекта $l$: 

\begin{itemize}
	\item $ \forall j:\ t.vc[j] := max(t.vc[j]\ , l.vc[j])$
\end{itemize}
При освобождении потоком $t_i$ синхронизационного объекта $l$: 

\begin{itemize}
	\item $t_i.vc[i]$++
	\item $ \forall j:\ l.vc[j] := max(l.vc[j]\ , t_i.vc[j])$
\end{itemize}
При обращении потока $t$ к разделяемой переменной $v$: 
\begin{itemize}
	\item Если $ \exists j:\ v.vc[j]\ >\ t.vc[j]$, то значит найдена гонка. 
	\item $v.vc$ $:=$ $t.vc$
\end{itemize}


В случае Java-программ данными разделяемыми переменными являются поля. 


\subsection{Возможности статического анализа для оптимизации jDRD}
Как видно из описания работы jDRD, каждое поле является потенциальным местом возникновения гонки.  
Для каждого поля в jDRD приходится хранить векторные часы. Применяя статический анализ можно выяснить, что некоторые поля корректно-синхронизированы --- то есть, при обращении к ним невозможно состояние гонки. Для таких полей можно не анализировать обращения и не хранить векторные часы. Это позволит ускорить динамический детектор и уменьшить его потребление памяти. 

\section{Статический анализ для поиска корректно-синхронизированных полей}

\subsection{Существующие возможности статического анализа}
В настоящее время статический анализ рассмотрен довольно широко.
В разделе \ref{StaticRaceDetection} были рассмотрены статические детекторы гонок. Существует достаточное количество программ, которые проводят статический анализ для различных целей. Немногие из них, такие как $FindBugs$ \cite{FindBugs} и $ThreadSafe$ \cite{ThreadSafe}, проводят анализ конкурентного доступа к данным. Но все эти реализации ориентированы на поиск ошибок в программах и для решения исходной задачи не подходят.

В работе \cite{Whaley:1999:CPE:320385.320400} приведен способ для нахождения объектов, которые не покидают контекст потока или метода. Результаты данной работы используются для выделения объектов на стеке вместо кучи, а также для ликвидации ненужных операций синхронизации.
 Если объект используется только в методе, в котором создается, то этот объект можно выделить на стеке. Если объект используется только в одном потоке, то при обращении к этому объекту можно избавиться от операций синхронизации. Целью работы являлась оптимизация компилятора, однако метод анализа, рассмотренный в данной работе,  представляет интерес для решения исходной задачи.

Существуют библиотеки, которые статическим анализом позволяют получать различные представления исходного кода для дальнейшего анализа. Такие программы не решают исходную задачу, но могут быть использованы, как вспомогательные в данной работе. 
Таким образом, задача поиска корректно-синхронизированных полей статическим анализом актуальна.
\subsection{Возможные подходы к анализу}
Объектами исследования при статическом анализе программ среди прочего являются представления исследуемой программы в виде графов (граф потока исполнения, граф использования объектов, $point$-$to$ граф \cite{Whaley:1999:CPE:320385.320400}). 
В данной работе проводится анализ графа потока исполнения. 
\\\emph{Граф потока исполнения\ (англ. control flow graph,\ CFG)} --- это все возможные пути исполнения части программы, представленные в виде графа. Вершинами данного графа являются последовательности операций, не содержащие в себе ни операций передачи управления, ни точек, на которые управление передается из других частей программы. Ребра показывают возможные переходы между операциями \cite{CFA}.
Построение данных графов зависит от выбранной формы представления программы. Для Java-программ изначально 
доступно представление в виде байт-кода. Если доступен исходный код, то можно проводить анализ самой Java-программы.
Данные представления неудобны для последующего анализа. Байт-код имеет большое количество инструкций. Java-код имеет большое количество синтаксических конструкций, которые трудно проанализировать. Поэтому для облегчения анализа часто используются специальные промежуточные представления.
\\\emph{Промежуточное представление (англ. Intermediate representation, IR)} --- язык абстрактной машины, упрощающий проведение анализа. Для Java-программ большинство промежуточных представлений строится на основе байт-кода.

Предлагаемый метод определяет поля, обращения к которым всегда защищены блокировкой. В качестве блокировок рассмотрены стандартные операции захвата и освобождения монитора, а также блокировки пакета java.util.concurrent.
\FloatBarrier
